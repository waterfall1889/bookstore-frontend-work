# Redis缓存日志输出测试指南

## 一、测试准备

### 1.1 环境要求
- Redis服务器已安装并配置
- Spring Boot应用已启动
- MySQL数据库正常运行
- 至少有1本测试图书（itemId）

### 1.2 日志查看位置
- **IDE控制台**：查看实时日志输出
- **日志文件**（如配置）：查看持久化日志
- **日志格式**：`时间戳 [级别] [类名] - 日志内容`

---

## 二、测试场景一：首次读写（缓存未命中）

### 2.1 测试步骤

1. **确保Redis运行**
   ```cmd
   redis-cli.exe ping
   # 应返回: PONG
   ```

2. **启动Spring Boot应用**
   - 观察启动日志，查找Redis初始化信息

3. **首次查询图书**
   - 使用Postman或浏览器访问：`GET /api/books/{bookId}`
   - 使用一个从未查询过的bookId

4. **观察日志输出**

### 2.2 预期日志输出

#### 应用启动时：
```
========== 开始初始化Redis配置 ==========
Redis连接工厂类型: org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory
✅ Redis连接测试成功 - 服务器正常运行
✅ Redis配置初始化完成 - 序列化器配置成功
========== Redis配置初始化结束 ==========

========== Redis缓存服务初始化成功 ==========
✅ Redis连接正常，缓存功能已启用
缓存配置: 基础信息TTL=3600秒, 库存信息TTL=1800秒
```

#### 首次查询时：
```
[ItemDao] ========== 开始查询图书 ========== - itemId: book000000001
[ItemDao] 步骤1: 尝试从Redis缓存读取 - itemId: book000000001
[Redis读取] 尝试从缓存获取完整图书信息 - itemId: book000000001
[Redis读取] 尝试读取图书基础信息 - key: book:info:book000000001, itemId: book000000001
[Redis读取] ⚠️ 缓存未命中（基础信息） - key: book:info:book000000001, itemId: book000000001
[Redis读取] 尝试读取图书库存 - key: book:stock:book000000001, itemId: book000000001
[Redis读取] ⚠️ 缓存未命中（库存） - key: book:stock:book000000001, itemId: book000000001
[Redis读取] ⚠️ 缓存不完整，无法构建完整图书信息 - itemId: book000000001 (info: false, stock: false)
[ItemDao] ⚠️ 缓存未命中，降级到数据库查询 - itemId: book000000001
[ItemDao] 步骤2: 从MySQL数据库查询 - itemId: book000000001
[ItemDao] ✅ 从数据库查询图书成功 - itemId: book000000001, 书名: Java编程思想, 库存: 100
[ItemDao] 步骤3: 将数据写入Redis缓存 - itemId: book000000001
[Redis写入] 开始写入完整图书信息 - itemId: book000000001
[Redis写入] 尝试写入图书基础信息 - key: book:info:book000000001, itemId: book000000001
[Redis写入] ✅ 写入图书基础信息到缓存成功 - key: book:info:book000000001, itemId: book000000001, TTL: 3600秒, 字段数: 8
[Redis写入] 尝试写入图书库存 - key: book:stock:book000000001, itemId: book000000001, stock: 100
[Redis写入] ✅ 写入图书库存到缓存成功 - key: book:stock:book000000001, itemId: book000000001, stock: 100, TTL: 1800秒
[Redis写入] ✅ 写入完整图书信息到缓存成功 - itemId: book000000001, 书名: Java编程思想, 库存: 100
[ItemDao] ✅ 数据已写入缓存，下次查询将命中缓存 - itemId: book000000001
[ItemDao] ========== 查询完成（数据库） ==========
```

### 2.3 日志解释

**关键点**：
- ✅ **应用启动**：Redis配置初始化成功，缓存服务已启用
- ⚠️ **缓存未命中**：首次查询，缓存中没有数据
- ✅ **数据库查询**：从MySQL数据库成功获取数据
- ✅ **写入缓存**：将查询结果写入Redis，包含基础信息和库存
- ✅ **TTL设置**：设置了过期时间（基础信息1小时，库存30分钟）

**截图要点**：
1. 截图完整的查询日志，突出显示：
   - "缓存未命中"
   - "从MySQL数据库查询"
   - "写入Redis缓存成功"
   - TTL信息

---

## 三、测试场景二：后续读写（缓存命中）

### 3.1 测试步骤

1. **立即再次查询相同图书**
   - 使用相同的bookId
   - 在缓存TTL时间内（1小时内）

2. **观察日志输出**

### 3.2 预期日志输出

```
[ItemDao] ========== 开始查询图书 ========== - itemId: book000000001
[ItemDao] 步骤1: 尝试从Redis缓存读取 - itemId: book000000001
[Redis读取] 尝试从缓存获取完整图书信息 - itemId: book000000001
[Redis读取] 尝试读取图书基础信息 - key: book:info:book000000001, itemId: book000000001
[Redis读取] ✅ 缓存命中（基础信息） - key: book:info:book000000001, itemId: book000000001, 字段数: 8
[Redis读取] 尝试读取图书库存 - key: book:stock:book000000001, itemId: book000000001
[Redis读取] ✅ 缓存命中（库存） - key: book:stock:book000000001, itemId: book000000001, stock: 100
[Redis读取] ✅ 从缓存构建完整图书信息成功 - itemId: book000000001, 书名: Java编程思想, 库存: 100
[ItemDao] ✅ 缓存命中！从Redis缓存获取图书成功 - itemId: book000000001, 书名: Java编程思想, 库存: 100
[ItemDao] ========== 查询完成（缓存） ==========
```

### 3.3 日志解释

**关键点**：
- ✅ **缓存命中**：直接从Redis读取，不需要查询数据库
- ✅ **速度快**：没有数据库查询操作
- ✅ **构建成功**：从缓存中成功组装完整的图书对象

**对比首次查询**：
- ❌ **没有**"缓存未命中"日志
- ❌ **没有**"从MySQL数据库查询"日志
- ❌ **没有**"写入Redis缓存"日志
- ✅ **只有**"缓存命中"和"查询完成（缓存）"

**截图要点**：
1. 对比首次查询和后续查询的日志
2. 突出显示：
   - "缓存命中"
   - "查询完成（缓存）"而不是"查询完成（数据库）"

---

## 四、测试场景三：创建订单（库存更新）

### 4.1 测试步骤

1. **创建订单**
   - 在购物车中添加商品
   - 提交订单

2. **观察日志输出**

### 4.2 预期日志输出

```
[OrderService] ========== 开始更新图书库存 ========== - itemId: book000000001, 订单: 1234567890
[OrderService] 库存变更详情 - itemId: book000000001, 书名: Java编程思想, 旧库存: 100, 减少: 2, 新库存: 98
[OrderService] 步骤1: 更新MySQL数据库中的库存
[ItemDao] ========== 开始保存/更新图书 ========== - itemId: book000000001
[ItemDao] ✅ 保存图书到数据库成功 - itemId: book000000001, 书名: Java编程思想, 库存: 98
[ItemDao] 步骤2: 同步更新Redis缓存 - itemId: book000000001
[Redis写入] ✅ 写入完整图书信息到缓存成功 - itemId: book000000001, 书名: Java编程思想, 库存: 98
[OrderService] ✅ MySQL数据库库存更新成功 - itemId: book000000001, 新库存: 98
[OrderService] 步骤2: 原子更新Redis缓存中的库存
[Redis更新] 尝试更新图书库存（原子操作） - key: book:stock:book000000001, itemId: book000000001, delta: -2
[Redis更新] ✅ 更新图书库存成功（原子操作） - key: book:stock:book000000001, itemId: book000000001, delta: -2, newStock: 98
[OrderService] ✅ Redis缓存库存更新成功（原子操作） - itemId: book000000001
[OrderService] ========== 库存更新完成 ==========
```

### 4.3 日志解释

**关键点**：
- ✅ **库存变更详情**：显示旧库存、减少数量、新库存
- ✅ **数据库更新**：首先更新MySQL数据库
- ✅ **缓存同步**：通过ItemDao.save()同步更新缓存
- ✅ **原子更新**：使用Redis的INCR命令原子更新库存（防止并发问题）
- ✅ **双重保证**：数据库和缓存都更新，确保一致性

**截图要点**：
1. 显示库存变更的完整流程
2. 突出显示：
   - "库存变更详情"
   - "原子操作"
   - "更新成功"

---

## 五、测试场景四：关闭Redis（降级处理）

### 5.1 测试步骤

1. **关闭Redis服务器**
   - 在Redis运行窗口中按 `Ctrl+C`
   - 或关闭Redis进程

2. **查询图书**
   - 使用Postman或浏览器访问：`GET /api/books/{bookId}`

3. **观察日志输出**

### 5.2 预期日志输出

#### Redis关闭后的查询：
```
[ItemDao] ========== 开始查询图书 ========== - itemId: book000000001
[ItemDao] 步骤1: 尝试从Redis缓存读取 - itemId: book000000001
[Redis读取] 尝试从缓存获取完整图书信息 - itemId: book000000001
[Redis读取] 尝试读取图书基础信息 - key: book:info:book000000001, itemId: book000000001
[Redis] ⚠️ Redis连接不可用: Connection refused (Connection refused)
[Redis读取] ❌ Redis不可用，跳过缓存读取 - itemId: book000000001
[Redis读取] ❌ Redis不可用，跳过库存缓存读取 - itemId: book000000001
[Redis读取] ⚠️ 缓存不完整，无法构建完整图书信息 - itemId: book000000001 (info: false, stock: false)
[ItemDao] ⚠️ 缓存未命中，降级到数据库查询 - itemId: book000000001
[ItemDao] 步骤2: 从MySQL数据库查询 - itemId: book000000001
[ItemDao] ✅ 从数据库查询图书成功 - itemId: book000000001, 书名: Java编程思想, 库存: 98
[ItemDao] 步骤3: 将数据写入Redis缓存 - itemId: book000000001
[Redis写入] 开始写入完整图书信息 - itemId: book000000001
[Redis] ⚠️ Redis连接不可用: Connection refused (Connection refused)
[Redis写入] ❌ Redis不可用，跳过基础信息缓存写入 - itemId: book000000001
[Redis写入] ❌ Redis不可用，跳过库存缓存写入 - itemId: book000000001
[ItemDao] ✅ 数据已写入缓存，下次查询将命中缓存 - itemId: book000000001
[ItemDao] ========== 查询完成（数据库） ==========
```

#### Redis关闭后的写操作：
```
[ItemDao] ========== 开始保存/更新图书 ========== - itemId: book000000001
[ItemDao] 步骤1: 保存到MySQL数据库 - itemId: book000000001
[ItemDao] ✅ 保存图书到数据库成功 - itemId: book000000001, 书名: Java编程思想, 库存: 95
[ItemDao] 步骤2: 同步更新Redis缓存 - itemId: book000000001
[Redis写入] 开始写入完整图书信息 - itemId: book000000001
[Redis] ⚠️ Redis连接不可用: Connection refused (Connection refused)
[Redis写入] ❌ Redis不可用，跳过基础信息缓存写入 - itemId: book000000001
[Redis写入] ❌ Redis不可用，跳过库存缓存写入 - itemId: book000000001
[ItemDao] ✅ Redis缓存更新完成 - itemId: book000000001
[ItemDao] ========== 保存/更新完成 ==========
```

### 5.3 日志解释

**关键点**：
- ⚠️ **Redis连接不可用**：检测到Redis连接失败
- ❌ **跳过缓存操作**：所有Redis操作都被跳过
- ⚠️ **自动降级**：自动降级到数据库查询
- ✅ **功能正常**：尽管缓存不可用，但数据库操作成功
- ✅ **系统继续运行**：不影响业务功能

**高可用性体现**：
- 系统在Redis宕机时仍能正常工作
- 所有业务功能（查询、更新）都正常
- 只是性能略有下降（无缓存加速）

**截图要点**：
1. 显示"Redis连接不可用"警告
2. 显示"降级到数据库查询"
3. 显示查询/更新仍然成功
4. 说明系统的高可用性

---

## 六、测试场景五：Redis恢复

### 6.1 测试步骤

1. **重新启动Redis**
   ```cmd
   redis-server.exe
   ```

2. **重启Spring Boot应用**（或等待自动重连）

3. **查询图书**

### 6.2 预期日志输出

#### 应用启动时：
```
========== 开始初始化Redis配置 ==========
Redis连接工厂类型: org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory
✅ Redis连接测试成功 - 服务器正常运行
✅ Redis配置初始化完成 - 序列化器配置成功
========== Redis配置初始化结束 ==========

========== Redis缓存服务初始化成功 ==========
✅ Redis连接正常，缓存功能已启用
缓存配置: 基础信息TTL=3600秒, 库存信息TTL=1800秒
```

#### 查询时：
```
[ItemDao] ========== 开始查询图书 ========== - itemId: book000000001
[Redis读取] ⚠️ 缓存未命中（基础信息） - key: book:info:book000000001, itemId: book000000001
[ItemDao] ⚠️ 缓存未命中，降级到数据库查询 - itemId: book000000001
[ItemDao] ✅ 从数据库查询图书成功 - itemId: book000000001, 书名: Java编程思想, 库存: 95
[Redis写入] ✅ 写入完整图书信息到缓存成功 - itemId: book000000001, 书名: Java编程思想, 库存: 95
[ItemDao] ✅ 数据已写入缓存，下次查询将命中缓存 - itemId: book000000001
```

### 6.3 日志解释

**关键点**：
- ✅ **Redis连接恢复**：应用检测到Redis可用
- ⚠️ **缓存已清空**：Redis重启后缓存数据丢失（如果未配置持久化）
- ✅ **重新加载**：查询后重新写入缓存
- ✅ **功能恢复**：缓存功能恢复正常

---

## 七、截图清单和Word文档建议

### 7.1 必须截图的内容

1. **✅ 应用启动日志**
   - Redis配置初始化
   - Redis连接测试成功
   - 缓存服务初始化成功

2. **✅ 首次查询日志**（场景一）
   - 缓存未命中
   - 数据库查询
   - 缓存写入成功

3. **✅ 后续查询日志**（场景二）
   - 缓存命中
   - 不包含数据库查询

4. **✅ 创建订单日志**（场景三）
   - 库存变更详情
   - 原子更新操作

5. **✅ Redis宕机日志**（场景四）
   - Redis连接不可用警告
   - 降级到数据库
   - 查询仍然成功

6. **✅ Redis恢复日志**（场景五）
   - Redis连接恢复
   - 缓存重新加载

### 7.2 Word文档结构建议

```
一、Redis缓存日志输出说明
   1. 日志格式和标识说明
   2. 日志级别说明

二、场景一：首次读写（缓存未命中）
   1. 测试步骤
   2. 日志截图
   3. 日志解释（逐行说明）

三、场景二：后续读写（缓存命中）
   1. 测试步骤
   2. 日志截图
   3. 日志解释
   4. 与首次查询的对比

四、场景三：创建订单（库存更新）
   1. 测试步骤
   2. 日志截图
   3. 日志解释
   4. 原子操作说明

五、场景四：关闭Redis（降级处理）
   1. 测试步骤
   2. 日志截图
   3. 日志解释
   4. 高可用性说明

六、场景五：Redis恢复
   1. 测试步骤
   2. 日志截图
   3. 日志解释

七、总结
   1. 日志输出特点
   2. 缓存效果分析
   3. 系统高可用性验证
```

---

## 八、常见问题

### Q1: 为什么首次查询没有缓存命中？
**A**: 首次查询时，Redis缓存中还没有该图书的数据，所以会查询数据库并写入缓存。

### Q2: 关闭Redis后系统还能运行吗？
**A**: 可以。系统设计了降级机制，Redis不可用时会自动降级到数据库查询，不影响业务功能。

### Q3: 为什么库存更新有两次日志？
**A**: 一次是通过ItemDao.save()同步更新，另一次是原子操作更新。双重更新确保数据库和缓存的一致性。

### Q4: 缓存什么时候过期？
**A**: 基础信息缓存1小时（3600秒），库存信息缓存30分钟（1800秒）。过期后会自动从数据库重新加载。

### Q5: 如何判断缓存是否命中？
**A**: 查看日志中的标记：
- ✅ "缓存命中" = 缓存命中
- ⚠️ "缓存未命中" = 缓存未命中，需要查询数据库

---

## 九、测试检查清单

- [ ] Redis服务器已启动并正常运行
- [ ] Spring Boot应用已启动
- [ ] 首次查询图书，截图日志
- [ ] 再次查询相同图书，截图日志并对比
- [ ] 创建订单，截图库存更新日志
- [ ] 关闭Redis，截图降级处理日志
- [ ] 重新启动Redis，截图恢复日志
- [ ] 所有截图已整理到Word文档
- [ ] 每个场景都有详细的日志解释

---

## 十、日志输出优化建议

如果需要更清晰的日志，可以：

1. **调整日志级别**
   - 生产环境：使用INFO级别
   - 开发/测试环境：使用DEBUG级别

2. **过滤日志**
   - 使用日志框架的过滤器
   - 只显示Redis相关日志

3. **日志文件**
   - 配置日志文件输出
   - 方便后续查看和分析

