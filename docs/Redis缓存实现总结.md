# Redis缓存实现总结

## 一、实现概述

本次实现了完整的Redis缓存系统，包括：

1. ✅ Redis依赖配置
2. ✅ Redis配置类和连接管理
3. ✅ 图书缓存服务（分离基础信息和库存）
4. ✅ 缓存集成到数据访问层和服务层
5. ✅ 写操作时同步更新缓存
6. ✅ Redis宕机时的降级处理
7. ✅ 详细的日志输出

## 二、核心设计

### 2.1 缓存分离设计

为了合理使用缓存，将图书数据分为两部分：

- **基础信息**（`book:info:{itemId}`）：itemName, author, price, coverUrl, isbn, publish, validness
  - 变更频率低
  - TTL：3600秒（1小时）
  - 使用Hash结构

- **库存信息**（`book:stock:{itemId}`）：remainNumber
  - 变更频率高（订单创建、库存调整）
  - TTL：1800秒（30分钟）
  - 使用String结构，支持原子操作

### 2.2 缓存策略

#### 读操作（Cache-Aside模式）

```
1. 先从Redis读取
2. 缓存命中 → 返回数据
3. 缓存未命中 → 从数据库读取 → 写入缓存 → 返回数据
```

#### 写操作（Write-Through模式）

```
1. 写入数据库
2. 同步更新缓存
3. 删除相关列表缓存
```

### 2.3 降级策略

当Redis不可用时：
1. 所有缓存操作捕获异常
2. 自动降级到数据库查询
3. 系统继续正常运行
4. 记录警告日志

## 三、实现的文件和功能

### 3.1 配置文件

- `pom.xml`：添加Redis依赖
- `application.properties`：Redis连接配置
- `RedisConfig.java`：Redis配置类，支持Redis不可用时降级

### 3.2 核心服务类

- `BookCacheService.java`：
  - 图书基础信息缓存
  - 图书库存缓存
  - 缓存读写操作
  - Redis不可用时的降级处理

### 3.3 修改的类

- `ItemDaoImpl.java`：
  - 读操作：先查缓存，未命中查数据库并写入缓存
  - 写操作：先写数据库，同步更新缓存
  - 删除操作：删除数据库和缓存

- `BookServiceImpl.java`：使用ItemDao，自动使用缓存

- `OrderServiceImpl.java`：
  - 订单创建时更新库存
  - 同时更新数据库和缓存（原子操作）

- `CartServiceImpl.java`：
  - 购物车操作时从缓存读取库存信息
  - 添加日志记录

- `BookController.java`：
  - 添加/更新图书时使用ItemDao，自动更新缓存

## 四、日志输出说明

### 4.1 日志级别

- **INFO**：正常的业务操作和缓存操作
- **DEBUG**：详细的缓存操作（命中/未命中）
- **WARN**：Redis不可用警告（系统降级）
- **ERROR**：Redis操作异常（不影响运行）

### 4.2 关键日志示例

#### 首次查询（缓存未命中）

```
INFO  - 开始查询图书 - itemId: book000000001
DEBUG - Redis不可用，跳过缓存读取 - itemId: book000000001
INFO  - 缓存未命中，从数据库查询图书 - itemId: book000000001
INFO  - 从数据库查询图书成功，写入缓存 - itemId: book000000001
INFO  - 写入图书基础信息到缓存成功 - itemId: book000000001, TTL: 3600秒
INFO  - 写入图书库存到缓存成功 - itemId: book000000001, stock: 100, TTL: 1800秒
```

#### 再次查询（缓存命中）

```
INFO  - 开始查询图书 - itemId: book000000001
INFO  - 从缓存读取图书基础信息成功 - itemId: book000000001
INFO  - 从缓存读取图书库存成功 - itemId: book000000001, stock: 100
INFO  - 从缓存构建完整图书信息成功 - itemId: book000000001
INFO  - 从缓存获取图书成功 - itemId: book000000001
```

#### 库存更新

```
INFO  - 更新库存 - itemId: book000000001, 旧库存: 100, 减少: 2, 新库存: 98
INFO  - 库存缓存更新完成 - itemId: book000000001
INFO  - 更新图书库存成功 - itemId: book000000001, delta: -2, newStock: 98
```

#### Redis宕机后

```
WARN  - Redis连接不可用: Connection refused
DEBUG - Redis不可用，跳过缓存读取 - itemId: book000000001
INFO  - 缓存未命中，从数据库查询图书 - itemId: book000000001
INFO  - 从数据库查询图书成功 - itemId: book000000001
```

## 五、测试要点

### 5.1 首次读写测试

1. 启动Redis和应用
2. 查询一个从未查询过的图书
3. 观察日志，确认：
   - 缓存未命中
   - 从数据库读取
   - 写入缓存成功

### 5.2 后续读写测试

1. 再次查询相同的图书（在TTL内）
2. 观察日志，确认：
   - 缓存命中
   - 不查询数据库

### 5.3 Redis宕机测试

1. 关闭Redis服务器
2. 执行查询和写操作
3. 观察日志，确认：
   - Redis不可用警告
   - 降级到数据库
   - 系统正常运行

### 5.4 库存更新测试

1. 创建订单
2. 观察日志，确认：
   - 库存更新
   - 缓存同步更新

## 六、注意事项

1. **Redis启动**：确保Redis服务器运行在localhost:6379

2. **首次启动**：如果Redis未启动，应用仍可启动，但缓存功能不可用（会降级到数据库）

3. **缓存一致性**：写操作会同步更新数据库和缓存，确保一致性

4. **TTL过期**：缓存设置了过期时间，过期后会自动重新加载

5. **降级机制**：Redis不可用时，系统自动降级，不影响功能

## 七、后续优化建议

1. **缓存预热**：应用启动时预加载热门图书到缓存

2. **缓存穿透防护**：对不存在的数据也缓存（防止频繁查询不存在的数据）

3. **缓存雪崩防护**：为缓存TTL添加随机值，避免大量缓存同时过期

4. **分布式锁**：高并发场景下使用分布式锁保证库存更新的一致性

5. **监控告警**：添加Redis监控，及时发现Redis故障

